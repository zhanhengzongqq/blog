- [正则常用语法](#%E6%AD%A3%E5%88%99%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95)
  - [表1.常用的元字符](#%E8%A1%A81%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%83%E5%AD%97%E7%AC%A6)
  - [表2.常用的限定符](#%E8%A1%A82%E5%B8%B8%E7%94%A8%E7%9A%84%E9%99%90%E5%AE%9A%E7%AC%A6)
  - [表3.常用的反义代码](#%E8%A1%A83%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%8D%E4%B9%89%E4%BB%A3%E7%A0%81)
  - [表4.常用分组语法](#%E8%A1%A84%E5%B8%B8%E7%94%A8%E5%88%86%E7%BB%84%E8%AF%AD%E6%B3%95)
  - [表5.懒惰限定符](#%E8%A1%A85%E6%87%92%E6%83%B0%E9%99%90%E5%AE%9A%E7%AC%A6)
  - [表6.常用的处理选项](#%E8%A1%A86%E5%B8%B8%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86%E9%80%89%E9%A1%B9)
- [正则平衡组](#%E6%AD%A3%E5%88%99%E5%B9%B3%E8%A1%A1%E7%BB%84)
  - [平衡组为了解决什么问题](#%E5%B9%B3%E8%A1%A1%E7%BB%84%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98)
  - [平衡组语法](#%E5%B9%B3%E8%A1%A1%E7%BB%84%E8%AF%AD%E6%B3%95)
### 正则常用语法

#### 表1.常用的元字符
代码|说明|
---|---:
. | 匹配除换行符以外的任意字符
\w | 匹配字母或数字或下划线或汉字
\s | 匹配任意的空白符
\d | 匹配数字
\b | 匹配单词的开始或结束
^ | 匹配字符串的开始
$ | 匹配字符串的结束

#### 表2.常用的限定符
代码|说明|
---|---:
\* | 重复零次或更多次
\+ | 重复一次或更多次
? | 	重复零次或一次
{n} | 	重复n次
{n,} | 重复n次或更多次
{n,m} | 重复n到m次
(exp) | 匹配exp,并捕获文本到自动命名的组里

#### 表3.常用的反义代码
代码|说明|
---|---:
\W | 匹配任意不是字母，数字，下划线，汉字的字符
\S | 匹配任意不是空白符的字符
\D | 匹配任意非数字的字符
\B | 匹配不是单词开头或结束的位置
[^x] | 匹配除了x以外的任意字符
[^aeiou] | 匹配除了aeiou这几个字母以外的任意字符

#### 表4.常用分组语法
代码|说明|代码|
---|---|---:
捕获 | (exp) | 匹配exp,并捕获文本到自动命名的组里
捕获 |(?\<name\>exp)|匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp) 
捕获 | (?:exp) | 匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言 | (?=exp) | 匹配exp前面的位置
零宽断言 | (?<=exp) | 匹配exp后面的位置
零宽断言 | (?!exp) | 匹配后面跟的不是exp的位置
零宽断言 | (?<!exp) | 匹配前面不是exp的位置
注释 | 	(?#comment)	| 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读


#### 表5.懒惰限定符

代码|说明|
---|---:
*? | 重复任意次，但尽可能少重复
+? | 重复1次或更多次，但尽可能少重复
?? | 重复0次或1次，但尽可能少重复
{n,m}? | 重复n到m次，但尽可能少重复
{n,}? | 重复n次以上，但尽可能少重复

#### 表6.常用的处理选项

名称|说明|
---|---:
IgnoreCase(忽略大小写) |匹配时不区分大小写。
Multiline(多行模式) | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)
Singleline(单行模式) | 更改.的含义，使它与每一个字符匹配（包括换行符\n）。
IgnorePatternWhitespace(忽略空白) | 忽略表达式中的非转义空白并启用由#标记的注释。
ExplicitCapture(显式捕获) |  仅捕获已被显式命名的组。

### 正则平衡组

#### 平衡组为了解决什么问题
> 有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用\(.+\)则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？    
为了避免(和\(把你的大脑彻底搞糊涂，我们还是用尖括号代替圆括号吧。现在我们的问题变成了如何把xx <aa <bbb> <bbb> aa> yy这样的字符串里，最长的配对的尖括号内的内容捕获出来？

#### 平衡组语法
- **(?'group')** 把捕获的内容命名为group,并压入堆栈(Stack)
- **(?'-group')** 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败
- **(?(group)yes|no)** 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分
- **(?!)** 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败
